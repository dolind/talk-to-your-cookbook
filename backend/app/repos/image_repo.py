import logging
from datetime import datetime
from typing import List, Optional

from sqlalchemy import delete, func, select
from sqlalchemy.exc import NoResultFound
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.ocr import BookScanORM, ImageORM
from app.schemas.mappers import image_row_to_dto
from app.schemas.ocr import PageScanCreate, PageScanRead, PageScanUpdate

logger = logging.getLogger(__name__)


class ImageRepository:
    def __init__(self, session: AsyncSession):
        self.s = session

    # ──────────────────────────────────────────────────────────────
    async def save(self, img: PageScanCreate, owner_id: str) -> PageScanRead:
        """
        Insert a new image row.  ID is generated by DB (`default=generate_uuid`).
        """
        book_stmt = select(BookScanORM.id).where(BookScanORM.id == img.bookScanID, BookScanORM.user_id == owner_id)
        if (await self.s.execute(book_stmt)).scalar_one_or_none() is None:
            raise NoResultFound("Book scan not found")

        # Get the next available page number for this book scan
        stmt = select(func.max(ImageORM.page_number)).where(ImageORM.book_scan_id == img.bookScanID)
        result = await self.s.execute(stmt)
        max_page_number = result.scalar()
        next_page_number = (max_page_number or 0) + 1
        row = ImageORM(
            filename=img.filename,
            book_scan_id=img.bookScanID,
            page_number=next_page_number,
            scan_date=datetime.now(),
        )
        self.s.add(row)
        await self.s.commit()
        await self.s.refresh(row)
        return image_row_to_dto(row)

    async def get(self, image_id: str) -> Optional[PageScanRead]:
        row: ImageORM | None = await self.s.get(ImageORM, image_id)
        return image_row_to_dto(row) if row else None

    async def get_owned(self, image_id: str, owner_id: str) -> Optional[PageScanRead]:
        stmt = (
            select(ImageORM)
            .join(BookScanORM, ImageORM.book_scan_id == BookScanORM.id)
            .where(ImageORM.id == image_id, BookScanORM.user_id == owner_id)
        )
        row = (await self.s.execute(stmt)).scalar_one_or_none()
        return image_row_to_dto(row) if row else None

    async def list_by_book(self, book_scan_id: str, owner_id: str) -> List[PageScanRead]:
        stmt = (
            select(ImageORM)
            .join(BookScanORM, ImageORM.book_scan_id == BookScanORM.id)
            .where(ImageORM.book_scan_id == book_scan_id, BookScanORM.user_id == owner_id)
            .order_by(ImageORM.page_number)
        )
        rows = (await self.s.execute(stmt)).scalars().all()
        return [image_row_to_dto(r) for r in rows]

    async def update_page_number(self, image_id: str, target_number: int):
        """
        Update the page number of an image if the target number is not already taken
        within the same book scan.
        Raises NoResultFound if image not found or target number already exists.
        """
        # Get the image and its book_scan_id
        stmt = select(ImageORM).where(ImageORM.id == image_id)
        result = await self.s.execute(stmt)
        row = result.scalar_one_or_none()

        if row is None:
            raise NoResultFound(f"Image with id {image_id} not found")

        book_scan_id = row.book_scan_id

        # Check if another page with the target number exists in the same book scan
        check_stmt = select(ImageORM.id).where(
            ImageORM.book_scan_id == book_scan_id,
            ImageORM.page_number == target_number,
            ImageORM.id != image_id,
        )
        existing = (await self.s.execute(check_stmt)).scalar_one_or_none()
        if existing is not None:
            raise ValueError(f"Page number {target_number} already exists in this book scan")

        # Perform the update
        row.page_number = target_number
        await self.s.commit()

    async def delete(self, image_id: str, owner_id: str) -> None:
        stmt = (
            delete(ImageORM)
            .where(ImageORM.id == image_id)
            .where(ImageORM.book_scan_id.in_(select(BookScanORM.id).where(BookScanORM.user_id == owner_id)))
        )
        result = await self.s.execute(stmt)
        if result.rowcount == 0:
            raise NoResultFound(f"Image with id {image_id} not found")
        await self.s.commit()

    async def update(self, img: PageScanUpdate, owner_id: Optional[str] = None) -> PageScanRead | None:
        """
        Updates one or more fields on the image row identified by `img.id`.
        Returns the updated ImageRead DTO.
        """
        stmt = select(ImageORM).where(ImageORM.id == img.id)
        if owner_id is not None:
            stmt = (
                select(ImageORM)
                .join(BookScanORM, ImageORM.book_scan_id == BookScanORM.id)
                .where(ImageORM.id == img.id, BookScanORM.user_id == owner_id)
            )
        result = await self.s.execute(stmt)
        row = result.scalar_one_or_none()
        if row is None:
            raise NoResultFound(f"Image with id {img.id} not found")

        if img.filename is not None:
            row.filename = img.filename
        if img.bookScanID is not None:
            if owner_id is not None:
                book_stmt = select(BookScanORM.id).where(
                    BookScanORM.id == img.bookScanID, BookScanORM.user_id == owner_id
                )
                if (await self.s.execute(book_stmt)).scalar_one_or_none() is None:
                    raise NoResultFound("Book scan not found")
            row.book_scan_id = img.bookScanID
        if img.page_number is not None:
            row.page_number = img.page_number
        if img.scanDate is not None:
            row.scan_date = img.scanDate
        if img.ocr_path is not None:
            row.ocr_path = img.ocr_path
        if img.title is not None:
            row.title = img.title
        if img.page_segments is not None:
            row.recipe_areas = [seg.model_dump() for seg in img.page_segments]
        if img.status is not None:
            row.status = img.status
        if img.page_type is not None:
            row.page_type = img.page_type

        await self.s.commit()
        return image_row_to_dto(row)
